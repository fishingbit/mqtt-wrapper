<link rel="import" href="../polymer/polymer-element.html">
<!--
Polymer Element that wraps other Elements and links them to MQTT topics. Needs a `mqtt-connection` element.


## Installation

`bower install hobbyquaker/mqtt-wrapper`


## Imports and mqtt-connection

```html
<script src="bower_components/webcomponentsjs/webcomponents-lite.js"></script>
<link rel="import" href="bower_components/polymer/polymer.html">

<link rel="import" href="bower_components/mqtt-connection/mqtt-connection.html">
<link rel="import" href="bower_components/mqtt-wrapper/mqtt-wrapper.html">

<mqtt-connection host="mqtt-broker" port="8080"></mqtt-connection>
```


## Usage Examples

Inserts the last received message on the MQTT topic `test/info` as innerHTML to the wrapped div:
```html
<mqtt-wrapper sub='[{"topic":"test/info","content":"html"}]'>
    <div></div>
</mqtt-wrapper>
```

Send the payload `1` the MQTT topic `test/button` when the wrapped paper-button is clicked:
```html
<mqtt-wrapper pub='[{"event":"click","topic":"test/button","payload":"1"}]'>
    <paper-button>Licht an</paper-button>
</mqtt-wrapper>
```

Wrapping a paper-toggle-button and linking it to [hue2mqtt.js](https://github.com/hobbyquaker/hue2mqtt.js)
topics to switch a Hue lamp on and off:
```html
<mqtt-connection host="microserver" port="8080"></mqtt-connection>

<mqtt-wrapper
        sub='[{"topic":"hue/status/lights/Hobbyraum/on","attribute":"checked","json":"val","type":"boolean"}]'
        pub='[{"event":"change","topic":"hue/set/lights/Hobbyraum/on","attribute":"checked"}]'>

    <paper-toggle-button></paper-toggle-button>

</mqtt-wrapper>
```

@element mqtt-wrapper
-->
<dom-module id="mqtt-wrapper">
    <script>
        /**
         * `mqtt-wrapper` wraps other Elements and links them to MQTT topics. Needs a `mqtt-connection` element.
         * ## Usage
         * In typical use, just put an element inside mqtt-wrapper.
         *
         * @customElement
         * @polymer
         */
        class MqttWrapper extends Polymer.Element {
            static get is() { return 'mqtt-wrapper'; }
            static get properties() {
                return {
                    /**
                     * Array defining mqtt topics to subscribe and what to do with incoming messages
                     * #### SubscriptionConfig properties
                     * * __topic__: String
                     *
                     *   MQTT topic to subscribe
                     * * __attribute__: String
                     *
                     *   An attribute of the child element that should be set on incoming MQTT messages.
                     * * __type__: String
                     *
                     *   Set to `boolean` if the attribute that should be set is of type Boolean.
                     * * __json__: String
                     *
                     *   If you're using JSON payloads in your MQTT messages you can set a property of the JSON object
                     *   here that should be used.
                     * * __content__: String
                     *
                     *   Use `text` or `html` to set the MQTT message as innerHTML or innerText of the child element.
                     *   Either use attribute _or_ content.
                     * * __disable__: String
                     *
                     *   You can set an attribute name of the child element here that will prevent updates if true.
                     *
                     * @type {Array<SubscriptionConfig>}
                     */
                    sub: {
                        type: Array
                    },

                    /**
                     * Array defining events of the wrapped element that should trigger a mqtt publish and what to publish.
                     * #### PublishConfig properties
                     * * __event__: String
                     *
                     *   An event of the child element that should trigger a MQTT publish.
                     * * __attribute__: String
                     *
                     *   An attribute of the child element that value should be used as publish payload.
                     * * __payload__: String
                     *
                     *   A fixed payload that should be published (either use attribute _or_ payload).
                     *
                     * @type {Array<PublishConfig>}
                     */
                    pub: {
                        type: Array
                    },

                    /**
                     *  Don't set attribute `disabled` on child element if MQTT connection is lost.
                     */
                    noDisable: {
                        type: Boolean,
                        value: false
                    }
                }
            }

            connectedCallback() {
                super.connectedCallback();

                const mqtt = document.querySelector('mqtt-connection');

                if (!mqtt) {
                    throw new Error('mqtt-connection not found');
                }

                const child = this.querySelector('*:first-child');

                if (!child) {
                    return;
                }

                console.log(this)

                if (!this.noDisable) {
                    mqtt.addEventListener('connected-changed', (event) => {
                        if (event.detail.value) {
                            child.removeAttribute('disabled')
                        } else {
                            child.setAttribute('disabled', true);
                        }
                    });
                }

                if (this.sub && this.sub.length > 0) {
                    this.sub.forEach(conf => {
                        mqtt.subscribe(conf.topic, payload => {
                            if (typeof conf.disable !== 'undefined') {
                                if (child[conf.disable]) {
                                    return;
                                }
                            }
                            if (typeof conf.json !== 'undefined' && payload.indexOf('{') !== -1) {
                                try {
                                    payload = JSON.parse(payload)[conf.json];
                                } catch (err) {
                                    console.error('json parse failed');
                                }
                            }
                            if (conf.negate) {
                                payload = !payload;
                            }

                            if (typeof conf.attribute !== 'undefined') {
                                if (conf.type === 'boolean' && !payload) {
                                    child.removeAttribute(conf.attribute);
                                } else {
                                    child.setAttribute(conf.attribute, payload);
                                }
                            } else if (conf.content === 'html') {
                                child.innerHTML = payload;
                            } else if (conf.content === 'text') {
                                child.textContent = payload;
                            }
                        });
                    });
                }

                if (this.pub && this.pub.length > 0) {
                    this.pub.forEach(conf => {
                        child.addEventListener(conf.event, () => {

                            if (typeof conf.payload !== 'undefined') {
                                mqtt.publish(conf.topic, conf.payload);
                            } else if (typeof conf.attribute !== 'undefined') {
                                mqtt.publish(conf.topic, child[conf.attribute]);
                            }

                        });
                    });
                }
            }
        }

        customElements.define(MqttWrapper.is, MqttWrapper);
    </script>
</dom-module>
