<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="mqtt-wrapper">
    <script>

        class MqttWrapper extends Polymer.Element {
            static get is() { return 'mqtt-wrapper'; }
            static get properties() {
                return {
                    /**
                     * Array defining mqtt topics to subscribe and what to do with incoming messages
                     * #### SubscriptionConfig properties
                     * * __topic__: String
                     *
                     *   MQTT topic to subscribe
                     * * __attribute__: String
                     *
                     *   An attribute of the child element that should be set on incoming MQTT messages.
                     * * __type__: String
                     *
                     *   Set to `boolean` if the attribute that should be set is of type Boolean.
                     * * __json__: String
                     *
                     *   If you're using JSON payloads in your MQTT messages you can set a property of the JSON object
                     *   here that should be used.
                     * * __content__: String
                     *
                     *   Use `text` or `html` to set the MQTT message as innerHTML or innerText of the child element.
                     *   Either use attribute _or_ content.
                     * * __disable__: String
                     *
                     *   You can set an attribute name of the child element here that will prevent updates if true.
                     *
                     * @type {Array<SubscriptionConfig>}
                     */
                    sub: {
                        type: Array,
                        observer: '__subChange'
                    },

                    /**
                     * Array defining events of the wrapped element that should trigger a mqtt publish and what to publish.
                     * #### PublishConfig properties
                     * * __event__: String
                     *
                     *   An event of the child element that should trigger a MQTT publish.
                     * * __attribute__: String
                     *
                     *   An attribute of the child element that value should be used as publish payload.
                     * * __payload__: String
                     *
                     *   A fixed payload that should be published (either use attribute _or_ payload).
                     * * __negate__: Boolean
                     *
                     *   Negate the payload. Useful e.g. to set a disabled attribute when the payload is false.
                     *
                     * @type {Array<PublishConfig>}
                     */
                    pub: {
                        type: Array,
                        observer: '__pubChange'
                    },

                    /**
                     *  Don't set attribute `disabled` on child element if MQTT connection is lost.
                     */
                    noDisable: {
                        type: Boolean,
                        value: false,
                        observer: '__noDisableChange'
                    }
                }
            }

            connectedCallback() {
                this.__mqtt = document.querySelector('mqtt-connection');
                this.__child = this.querySelector('*:first-child');
                this.__eventHandlers = [];
                this.__subscriptions = [];

                super.connectedCallback();
            }

            __removeEventHandlers() {
                this.__eventHandlers.forEach(eh => {
                    this.__child.removeEventListener(eh.event, eh.handler);
                });
                this.__eventHandlers = [];
            }

            __addEventHandlers() {
                if (this.pub && this.pub.length > 0) {
                    this.pub.forEach(conf => {
                        const handler = () => {
                            if (typeof conf.payload !== 'undefined') {
                                this.__mqtt.publish(conf.topic, conf.payload);
                            } else if (typeof conf.attribute !== 'undefined') {
                                this.__mqtt.publish(conf.topic, this.__child[conf.attribute]);
                            }
                        };
                        this.__eventHandlers.push({event: conf.event, handler});
                        this.__child.addEventListener(conf.event, handler);
                    });
                }

            }

            __removeSubscriptions() {
                this.__subscriptions.forEach(sid => {
                    this.__mqtt.unsubscribe(sid);
                });
                this.__subscriptions = [];
            }

            __addSubscriptions() {
                if (this.sub && this.sub.length > 0) {
                    this.sub.forEach(conf => {
                        this.__subscriptions.push(this.__mqtt.subscribe(conf.topic, payload => {
                            if (typeof conf.disable !== 'undefined') {
                                if (this.__child[conf.disable]) {
                                    return;
                                }
                            }
                            if (typeof conf.json !== 'undefined' && payload.indexOf('{') !== -1) {
                                try {
                                    payload = JSON.parse(payload)[conf.json];
                                } catch (err) {
                                    console.error('json parse failed');
                                }
                            }
                            if (conf.negate) {
                                payload = !payload;
                            }
                            if (typeof conf.attribute !== 'undefined') {
                                if (conf.type === 'boolean' && !payload) {
                                    this.__child.removeAttribute(conf.attribute);
                                } else {
                                    this.__child.setAttribute(conf.attribute, payload);
                                }
                            } else if (conf.content === 'html') {
                                this.__child.innerHTML = payload;
                            } else if (conf.content === 'text') {
                                this.__child.textContent = payload;
                            }
                        }));
                    });
                }
            }


            /**
             * Call this method when the wrapped element has changed.
             */
            refresh() {
                this.__removeEventHandlers();
                this.__removeSubscriptions();
                this.__child = this.querySelector('*:first-child');
                this.__addEventHandlers();
                this.__addSubscriptions();
            }

            __subChange() {
                this.__removeSubscriptions();
                this.__addSubscriptions();
            }

            __pubChange() {
                this.__removeEventHandlers();
                this.__addEventHandlers();
            }

            __noDisableChange() {
                if (!this.noDisable) {
                    this.__connectedChangeHandler = event => {
                        if (event.detail.value) {
                            this.__child.removeAttribute('disabled')
                        } else {
                            this.__child.setAttribute('disabled', true);
                        }
                    };
                    this.__mqtt.addEventListener('connected-changed', this.__connectedChangeHandler);
                } else {
                    if (this.__connectedChangeHandler) {
                        this.__mqtt.removeEventListener('connected-change', this.__connectedChangeHandler);
                    }
                }
            }
        }

        customElements.define(MqttWrapper.is, MqttWrapper);
    </script>
</dom-module>
