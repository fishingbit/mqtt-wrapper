<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="mqtt-wrapper">
    <script>
        /**
         *
         * `mqtt-wrapper` wraps other Elements and links them to MQTT topics
         * ## Usage
         * In typical use, just put an element inside mqtt-wrapper
         *
         * @customElement
         * @polymer
         *
         */
        class MqttWrapper extends Polymer.Element {
            static get is() { return 'mqtt-wrapper'; }
            static get properties() {
                return {
                    /**
                     * Object defining mqtt topics to subscribe and what to do with incoming messages
                     *
                     * @type {{object}}
                     */
                    sub: {
                        type: Object
                    },
                    /**
                     * Object defining events of the wrapped element that should trigger a mqtt publish and what to publish
                     *
                     * @type {{object}}
                     */
                    pub: {
                        type: Object
                    },
                    /**
                     *  Don't set attribute `disabled` on child element if MQTT connection is lost
                     */
                    noDisable: {
                        type: Boolean,
                        value: false
                    }
                }
            }

            connectedCallback() {
                super.connectedCallback();

                const mqtt = document.querySelector('mqtt-connection');

                if (!mqtt) {
                    throw new Error('mqtt-connection not found');
                }

                const child = this.querySelector('*:first-child');

                if (!child) {
                    return;
                }

                if (!this.noDisable) {
                    mqtt.addEventListener('connected-changed', (event) => {
                        if (event.detail.value) {
                            child.removeAttribute('disabled')
                        } else {
                            child.setAttribute('disabled', true);
                        }
                    });
                }

                if (typeof this.sub === 'object') {
                    Object.keys(this.sub).forEach(topic => {
                        const conf = this.sub[topic];
                        if (typeof conf !== 'object') {
                            return;
                        }
                        mqtt.subscribe(topic, payload => {
                            if (typeof conf.disable !== 'undefined') {
                                if (child[conf.disable]) {
                                    return;
                                }
                            }
                            if (typeof conf.json !== 'undefined' && payload.indexOf('{') !== -1) {
                                try {
                                    payload = JSON.parse(payload)[conf.json];
                                } catch (err) {
                                    console.error('json parse failed');
                                }
                            }
                            if (conf.negate) {
                                payload = !payload;
                            }

                            if (typeof conf.attribute !== 'undefined') {
                                if (conf.type === 'boolean' && !payload) {
                                    child.removeAttribute(conf.attribute);
                                } else {
                                    child.setAttribute(conf.attribute, payload);
                                }
                            } else if (conf.content === 'html') {
                                child.innerHTML = payload;
                            } else if (conf.content === 'text') {
                                child.textContent = payload;
                            }
                        });
                    });


                    if (typeof this.pub === 'object') {
                        Object.keys(this.pub).forEach(event => {
                            child.addEventListener(event, () => {
                                const conf = this.pub[event];

                                if (typeof conf.payload !== 'undefined') {
                                    mqtt.publish(conf.topic, conf.payload);
                                } else if (typeof conf.attribute !== 'undefined') {
                                    mqtt.publish(conf.topic, child[conf.attribute]);
                                }

                            });
                        });
                    }
                }
            }
        }

        customElements.define(MqttWrapper.is, MqttWrapper);
    </script>
</dom-module>
